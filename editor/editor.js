// Generated by CoffeeScript 1.10.0
(function() {
  var KeyListener, TOOLTIP_TTL, enableEditorFunctionality, loadSampleText, suggestCommand,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  String.prototype.occurrencesOf = function(substr) {
    var i, j, occ, ref;
    occ = 0;
    for (i = j = 0, ref = this.length - substr.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (this.slice(i).startsWith(substr)) {
        occ++;
      }
    }
    return occ;
  };

  String.prototype.matchesOf = function(regex) {
    var match, source;
    source = regex.source;
    regex = new RegExp(source, "g");
    match = this.match(regex);
    if (match != null) {
      return match.length;
    }
    return 0;
  };

  Array.prototype.containsOnly = function(targets) {
    var elem, j, len;
    for (j = 0, len = this.length; j < len; j++) {
      elem = this[j];
      if (!_.contains(targets, elem)) {
        return false;
      }
    }
    return true;
  };

  Array.prototype.contains = function(target) {
    return _.contains(this, target);
  };

  this.Keys = {
    left: 37,
    right: 39,
    up: 38,
    down: 40,
    mouse: -1
  };

  Keys.directional = [Keys.left, Keys.right, Keys.up, Keys.down, Keys.mouse];

  KeyListener = (function() {
    KeyListener.prototype.MAX_TIME_BETWEEN_STROKES = 750;

    KeyListener.prototype.MIN_MOVEMENT_STROKES = 1;

    KeyListener.prototype.MAX_WORD_MOVEMENT_COUNT = 6;

    KeyListener.prototype.MAX_VERT_MOVEMENT_COUNT = 40;

    KeyListener.prototype.MAX_ANCHOR_MOVEMENT_COUNT = 4;

    KeyListener.property('seqStart', {
      set: function(index) {
        return this._seqStartIndex = index;
      },
      get: function() {
        var lineCol, textToCursor;
        textToCursor = this.text.slice(0, this._seqStartIndex);
        lineCol = this.computeLineCol(textToCursor, this._seqStartIndex);
        return $.extend({
          index: this._seqStartIndex
        }, lineCol);
      }
    });

    KeyListener.property('seqEnd', {
      set: function(index) {
        return this._seqEndIndex = index;
      },
      get: function() {
        var lineCol, textToCursor;
        textToCursor = this.text.slice(0, this._seqEndIndex);
        lineCol = this.computeLineCol(textToCursor, this._seqEndIndex);
        return $.extend({
          index: this._seqEndIndex
        }, lineCol);
      }
    });

    KeyListener.prototype.computeLineCol = function(str, index) {
      var startOfLine;
      startOfLine = str.lastIndexOf('\n');
      return {
        line: 1 + str.occurrencesOf('\n'),
        col: index - startOfLine
      };
    };

    KeyListener.property('cursorIndex', {
      get: function() {
        var pos;
        pos = this.editor.getCursor();
        return this.editor.indexFromPos(pos);
      }
    });

    KeyListener.property('text', {
      get: function() {
        return this.editor.getValue();
      }
    });

    function KeyListener(editor1) {
      var code, name, self;
      this.editor = editor1;
      this.supportedKeyCodes = [];
      for (name in Keys) {
        code = Keys[name];
        this.supportedKeyCodes.push(code);
      }
      this.currSeq = [];
      self = this;
      this.editor.on("keydown", function() {
        return self.registerKeyDown(event.which);
      });
      this.editor.on("keyup", function() {
        return self.registerKeyUp(event.which);
      });
      this.editor.on("mousedown", function() {
        return self.registerMouseDown();
      });
      this.editor.on("mouseup", function() {
        return self.registerMouseUp();
      });
    }

    KeyListener.prototype.registerKeyDown = function(code) {
      if (indexOf.call(this.supportedKeyCodes, code) < 0) {
        return;
      }
      return this.registerPossibleStart();
    };

    KeyListener.prototype.registerKeyUp = function(code) {
      if (indexOf.call(this.supportedKeyCodes, code) < 0) {
        return;
      }
      this.registerEnd();
      this.currSeq.push(code);
      if (this.timer != null) {
        clearTimeout(this.timer);
      }
      return this.timer = setTimeout(this.processSeq.bind(this), this.MAX_TIME_BETWEEN_STROKES);
    };

    KeyListener.prototype.registerPossibleStart = function() {
      if (this.currSeq.length === 0) {
        return this.seqStart = this.cursorIndex;
      }
    };

    KeyListener.prototype.registerEnd = function() {
      return this.seqEnd = this.cursorIndex;
    };

    KeyListener.prototype.registerMouseDown = function() {
      return this.registerPossibleStart();
    };

    KeyListener.prototype.registerMouseUp = function() {
      this.registerEnd();
      this.currSeq.push(Keys.mouse);
      return this.processSeq();
    };

    KeyListener.prototype.processSeq = function() {
      var beforeStart, from, last, next, prevRelevant, to, traversed, wentForward;
      wentForward = this.seqEnd.index - this.seqStart.index > 0;
      if (this.seqStart.index === this.seqEnd.index) {
        traversed = '';
      } else {
        if (wentForward) {
          from = this.seqStart.index;
          to = this.seqEnd.index;
        } else {
          from = this.seqEnd.index;
          to = this.seqStart.index;
        }
        traversed = this.text.slice(from, +(to - 1) + 1 || 9e9);
      }

      /*
      When traversing 'abcd' from left to right -->, the letter we stopped at is 'd'
      But traversing it the other way, right to left <--, the letter we stopped at is 'a'
      Same goes for the next char: on left to right direction, the next char is the one to the right of d
      But on right to left direction, the next char is the one before a
       */
      beforeStart = this.text[this.seqStart.index - 1];
      last = wentForward ? traversed.slice(-1) : traversed[0];
      next = wentForward ? this.text[this.seqEnd.index] : this.text[this.seqEnd.index - 1];
      if (this.currSeq.containsOnly(Keys.directional) && ((this.currSeq.contains(Keys.mouse) && traversed.length > 0) || (traversed.length >= this.MIN_MOVEMENT_STROKES && this.currSeq.length >= this.MIN_MOVEMENT_STROKES))) {
        prevRelevant = false;
        prevRelevant = this.suggestVertMovement(wentForward);
        if (!prevRelevant) {
          prevRelevant = this.suggestHomeEndMovement(next);
        }
        if (!prevRelevant) {
          prevRelevant = this.suggestWordMovement(traversed, wentForward, beforeStart, last, next);
        }
        if (!prevRelevant) {
          this.suggestAnchorMovement(traversed, wentForward);
        }
      }
      this.currSeq = [];
      return this.timer = null;
    };

    KeyListener.prototype.suggestVertMovement = function(wentForward) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#up-down-motions)
        k       [count] lines upward.
        j			  [count] lines downward.
      
        Remember: J looks a bit like a down arrow so it means go down
                  Also in romanian the word for down starts with J
       */
      var distance, immNext, lineEndCol, lineStartIndex, motion;
      distance = Math.abs(this.seqEnd.line - this.seqStart.line);
      if (distance === 0 || distance > this.MAX_VERT_MOVEMENT_COUNT) {
        return false;
      }
      immNext = this.text[this.seqEnd.index];
      if (this.seqEnd.line === 1) {
        lineEndCol = this.text.indexOf('\n');
      } else {
        lineStartIndex = 1 + this.text.slice(0, +(this.seqEnd.index - 1) + 1 || 9e9).lastIndexOf('\n');
        lineEndCol = this.text.slice(lineStartIndex).indexOf('\n');
      }
      if (this.seqEnd.col === this.seqStart.col || ((immNext === '\n' || immNext === void 0) && lineEndCol < this.seqStart.col)) {
        motion = wentForward ? "j" : "k";
        suggestCommand(this.editor, this.seqEnd.line, distance, motion);
        return true;
      }
      return false;
    };

    KeyListener.prototype.suggestHomeEndMovement = function(next) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#<Home>)
        0			  To the first character of the line. motion.
        ^			  To the first non-blank character of the line. motion.
        $       To the end of the line.
       */
      var fromLineStart, lineStart, stoppedAt;
      if (this.seqStart.line !== this.seqEnd.line) {
        return false;
      }
      if (this.seqEnd.col === 1) {
        suggestCommand(this.editor, this.seqEnd.line, 1, '0');
        return true;
      }
      if (next === '\n') {
        suggestCommand(this.editor, this.seqEnd.line, 1, '$');
        return true;
      }
      stoppedAt = this.text[this.seqEnd.index];
      if (stoppedAt != null ? stoppedAt.match(/^\S$/) : void 0) {
        lineStart = this.seqEnd.line === 1 ? 0 : 1 + this.text.slice(0, +this.seqEnd.index + 1 || 9e9).lastIndexOf('\n');
        fromLineStart = this.text.slice(lineStart, +(this.seqEnd.index - 1) + 1 || 9e9);
        if (fromLineStart.match(/^\s*$/)) {
          suggestCommand(this.editor, this.seqEnd.line, 1, '^');
          return true;
        }
      }
      return false;
    };

    KeyListener.prototype.suggestWordMovement = function(traversed, wentForward, beforeStart, last, next) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#word-motions)
        4. Word motions
      
          w			[count] words forward. motion.
          W			[count] WORDS forward. motion.
          e			Forward to the end of word [count]. Does not stop in an empty line.
          E			Forward to the end of WORD [count]. Does not stop in an empty line.
          b			[count] words backward. motion.
          B			[count] WORDS backward. motion.
          ge	  Backward to the end of word [count].
          gE		Backward to the end of WORD [count].
      
          A word consists of a sequence of letters, digits and underscores, or a
          sequence of other non-blank characters, separated with white space (spaces,
          tabs, <EOL>).  This can be changed with the 'iskeyword' option.  An empty line
          is also considered to be a word.
      
          A WORD consists of a sequence of non-blank characters, separated with white
          space.  An empty line is also considered to be a WORD.
      
      eg:
      This "stuff" is not-so difficult!
      wwww  wwwww  ww www ww wwwwwwwww
      WWWW WWWWWWW WW WWWWWW WWWWWWWWWW
       */
      var count, motion, shouldBeWS, shouldNotBeWS;
      if (wentForward) {
        shouldBeWS = last;
        shouldNotBeWS = next;
      } else {
        shouldBeWS = next;
        shouldNotBeWS = last;
      }
      if (!(next === void 0 || (shouldBeWS.match(/^\s$/) && shouldNotBeWS.match(/^\S$/)))) {
        return false;
      }
      count = traversed.matchesOf(/\s+/) + traversed.occurrencesOf("\n\n");
      if (!wentForward && beforeStart !== void 0 && (beforeStart != null ? beforeStart.match(/\S/) : void 0)) {
        count++;
      }
      motion = wentForward ? "W" : "B";
      if (count > this.MAX_WORD_MOVEMENT_COUNT) {
        return false;
      }
      suggestCommand(this.editor, this.seqEnd.line, count, motion);
      return true;
    };

    KeyListener.prototype.suggestAnchorMovement = function(traversed, wentForward) {

      /*
      From the Vim documentation (online at http://vimdoc.sourceforge.net/htmldoc/motion.html#word-motions)
        2. Left-right motions
      
        f{char}   To the [count]'th occurrence of {char} to the right. The cursor is placed on {char}.
        F{char}   To the [count]'th occurrence of {char} to the left.  The cursor is placed on {char}.
      
        t{char}   Till before [count]'th occurrence of {char} to the right. The cursor is placed on the character left of {char}.
        T{char}   Till after  [count]'th occurrence of {char} to the left.  The cursor is placed on the character right of {char}.
      
        eg:
        abc def?
        f?---->
        t?--->
      
        def? 123456
           <-----F?
            <----T?
      
        Remember: F can be for Find or Forward to
        We say an anchor is a defining element, one you can jump to, anchor to
       */
      var count, motion, next;
      next = this.text[this.seqEnd.index];
      count = traversed.occurrencesOf(next);
      if (wentForward && traversed[0] !== next) {
        count++;
      }
      motion = wentForward ? 'f' : 'F';
      if (count <= this.MAX_ANCHOR_MOVEMENT_COUNT) {
        suggestCommand(this.editor, this.seqEnd.line, count, motion + next);
        return true;
      }
      return false;
    };

    return KeyListener;

  })();

  $(function() {
    var editor, textarea;
    textarea = $("#editor")[0];
    editor = enableEditorFunctionality(textarea);
    loadSampleText(editor, function() {
      var listener;
      return listener = new KeyListener(editor);
    });
    return Opentip.styles.Suggestion = {
      "extends": "glass",
      target: true,
      stem: true,
      showOn: "creation"
    };
  });

  enableEditorFunctionality = function(textarea) {
    var editor;
    editor = CodeMirror.fromTextArea(textarea, {
      lineNumbers: true,
      autofocus: true,
      theme: "solarized light",
      keyMap: "vim",
      mode: "gfm",
      matchBrackets: true,
      closeBrackets: true,
      styleActiveLine: true
    });
    editor.setSize("100%", "600px");
    $(".CodeMirror").css("font-family", "Hack, monospaced");
    return editor;
  };

  loadSampleText = function(editor, whenDone) {
    return $.ajax({
      url: "samples/gfm sample.txt",
      dataType: "text",
      success: function(data) {
        editor.setValue(data);
        return whenDone();
      }
    });
  };

  TOOLTIP_TTL = 5;

  suggestCommand = function(editor, line, count, motion) {
    var content, hideIt, j, len, lineNo, lineNumber, lineNumbers, tip;
    lineNumbers = $(".CodeMirror-linenumber");
    for (j = 0, len = lineNumbers.length; j < len; j++) {
      lineNumber = lineNumbers[j];
      if (lineNumber.innerHTML === line.toString()) {
        lineNo = $(lineNumber);
        break;
      }
    }
    content = "" + (count === 1 ? "" : count) + motion;
    tip = new Opentip(lineNo, content, {
      style: "Suggestion",
      tipJoint: "center right",
      className: "suggestion-tooltip",
      group: "suggestions"
    });
    hideIt = function() {
      return tip.hide();
    };
    return setTimeout(hideIt, TOOLTIP_TTL * 1000);
  };

}).call(this);

//# sourceMappingURL=editor.js.map
